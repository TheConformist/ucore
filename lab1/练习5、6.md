## 练习5

![image-20221012111920541](C:\Users\xumin\AppData\Roaming\Typora\typora-user-images\image-20221012111920541.png)

__1__

```c
void
print_stackframe(void) {
     /* LAB1 YOUR CODE : STEP 1 */
     /* (1) call read_ebp() to get the value of ebp. the type is (uint32_t);
      * (2) call read_eip() to get the value of eip. the type is (uint32_t);
      * (3) from 0 .. STACKFRAME_DEPTH
      *    (3.1) printf value of ebp, eip
      *    (3.2) (uint32_t)calling arguments [0..4] = the contents in address (uint32_t)ebp +2 [0..4]
      *    (3.3) cprintf("\n");
      *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.
      *    (3.5) popup a calling stackframe
      *           NOTICE: the calling funciton's return addr eip  = ss:[ebp+4]
      *                   the calling funciton's ebp = ss:[ebp]
      */
      uint32_t ebp=read_ebp();  //(1)
      uint32_t eip=read_eip();  //(2)
      for (int i=0;i<STACKFRAME_DEPT H && ebp!=0;i++)
      {
	      cprintf("ebp:0x%08x eip:0x%08x args:", ebp, eip);//(3.1)
	      uint32_t *args = (uint32_t *)ebp+2;
	      for(int j=0;j<4;j++)
	      {
		      cprintf("0x%08x ",args[j]);
	      }//(3.2)
	      cprintf("\n");//(3.3)
	      print_debuginfo(eip-1);//(3.4)
	      eip = ((uint32_t *)ebp)[1];
	      ebp = ((uint32_t *)ebp)[0];//(3.5)
      }
}
```

```
read_ebp()：读取当前ebp寄存器的值
read_epi()：读取当前epi寄存器的值
print_debuginfo()：查找对应函数名并打印至屏幕
0x%08x  0x为普通字符，输出的时候会原样输出为0x。%08x为整型以16进制方式输出的格式字符串，会把后续对应参数的整型数字，以16进制输出。08的含义为，输出的16进制值占8位，不足部分左侧补0。
print_debuginfo(eip-1); eip保存下一条指令的地址，所以要减1
```



**ss:[ebp+4]处为返回地址，ss:[ebp+8]处为第一个参数值（最后一个入栈的参数值，此处假设其占用 4 字节内存，对应32位系统），ss:[ebp-4]处为第一个局部变量，ss:[ebp]处为上一层 ebp 值**

由于ebp装的是上层函数的基地址，所以每次循环都会跑到上层函数

```
eip = ((uint32_t *)ebp)[1]; 
ebp = ((uint32_t *)ebp)[0];
```



ebp的内容是调用它的函数栈帧的ebp值。因此ebp[0]

ebp+4是返回地址 eip 即ebp[1] // uint32_t  （32bits/8=4bytes，所以只需[1]）



每一个栈帧，eip是ebp+4，得到的ebp是上一个函数的ebp，eip也跟着变

uint32_t  32位无符号整数 就是4byte，因此ebp寻址只需加1



__2__

![image-20221012111122626](C:\Users\xumin\AppData\Roaming\Typora\typora-user-images\image-20221012111122626.png)

输出大致一致

从obj/bootblock.asm文件中知道整个栈的栈顶地址为0x00007c00

ebp的值是kern_init函数的栈顶地址

eip：kern_init函数的返回地址。bootmain函数调用kern_init对应的指令的下一条指令的地址

> bootloader设置的堆栈从0x7c00开始，使用”call bootmain”转入bootmain函数。
>  call指令压栈，所以bootmain中ebp为0x7bf8。eip表示当前的PC寄存器的值，由于代码不同，所以可能各不相同。

![image-20221012161306127](C:\Users\xumin\AppData\Roaming\Typora\typora-user-images\image-20221012161306127.png)

kern_init函数没有传参数

![image-20221014200233031](C:\Users\xumin\AppData\Roaming\Typora\typora-user-images\image-20221014200233031.png)

![image-20221014200333235](C:\Users\xumin\AppData\Roaming\Typora\typora-user-images\image-20221014200333235.png)

> 一般来说，args存放的4个dword是对应4个输入参数的值。但之前我们已经发现这里其实并没
> 有传入参数。并且栈顶的位置恰好在bootloader第一条指令存放的地址的上面，而args恰好是
> kern_int的ebp寄存器指向的栈顶往上第2~5个单元，因此args存放的就是boot loader指令的前16个
> 字节！可以对比obj/bootblock.asm文件来验证（验证时要注意系统是小端字节序）



总结一下对函数栈帧的认识



## 练习6

__中断与异常__

操作系统和CPU能够一起提供某种机制，让外设在需要操作系统处理外设相关事件的时候，能够“主动通知”操作系统，即打断操作系统和应用的正常执行，让操作系统完成外设的相关处理，然后再恢复操作系统和应用的正常执行。在操作系统中，这种机制称为中断机制。



中断：异步中断。与CPU执行无关，由CPU外部设备引起的外部事件导致的中断。

外部设备跟不上cpu的运行速度，如果cpu一直等（主动关心）外部设备，浪费CPU资源，为了不浪费，所以通过中断的方式让CPU停下来

异常：内部中断。在CPU执行指令期间检测到不正常的或非法的条件（地址越界）

软中断：陷入中断。在程序中使用__请求系统服务__的系统调用而引发的事件。





__中断描述符表（IDT）__

把每个中断或异常编号和一个指向中断服务例程的描述符联系起来。

IDT是一个8字节的描述符数组

CPU通过IDT寄存器（IDTR）的内容来寻址IDT的起始地址。指令LIDT和SIDT用来操作IDTR。

**问题1**

打开kern下mm的mmu.c文件：

```c
/* Gate descriptors for interrupts and traps */
struct gatedesc {
    unsigned gd_off_15_0 : 16;        // low 16 bits of offset in segment
    unsigned gd_ss : 16;            // segment selector
    unsigned gd_args : 5;            // # args, 0 for interrupt/trap gates
    unsigned gd_rsv1 : 3;            // reserved(should be zero I guess)
    unsigned gd_type : 4;            // type(STS_{TG,IG32,TG32})
    unsigned gd_s : 1;                // must be 0 (system)
    unsigned gd_dpl : 2;            // descriptor(meaning new) privilege level
    unsigned gd_p : 1;                // Present
    unsigned gd_off_31_16 : 16;        // high bits of offset in segment
};
```

总字节：16+16+5+3+4+1+2+1+16 = 64 bit = 8byte

one version：*一个表项占8个字节，其中0-1两个字节表示段长度限制（IDT limit），2-7字节是基址（IDT Base Address）。2-3是段地址，0-1 + 6-7共同拼成位移。*

another version：0-1字节，6-7字节分别储存偏移量的低16位和高16位。2-3字节是段选择子（是子不是字？必吐槽）

third version：前两个和后两个字节拼接起来即为中断处理代码的入口地址，再和段选择子两者联合便是中断处理程序的入口地址



保护模式下，使用分段存储管理机制

分段机涉及4个关键内容：逻辑地址、**段描述符（描述段的属性）**、段描述符表（包含多个段描述符的“数组”）、段选择子（**段寄存器**，**用于定位段描述符表中表项的索引**）。负责转换**逻辑地址**（Logical Address,应用程序员看到的地址）到**物理地址**

**逻辑地址（由段选择子selector****和段偏移offset****组成）**中的段选择子的内容作为段描述符表的索引，找到表中对应的段描述符，然后把段描述符中保存的段基址加上段偏移值，形成线性地址（Linear Address）。如果不启动分页存储管理机制，则线性地址等于物理地址。

即 **段选择子（索引）-->**段描述表对应的描述符**（段基址）+**偏移**-->**线性地址**



用

> 使用段选择符中的偏移值在GDT（全局描述符表） 或 LDT（局部描述符表）中定位相  应的段描述符。
>
> **利用段描述符校验段的访问权限和范围，以确保该段是可以访问的并且偏移量位于段**  **界限内。**
>
> 利用段描述符中取得的段基地址加上偏移量，形成一个线性地址。



**问题2**

题干里给了俩提示，一个是SETGATE宏，它负责填充idt数组。一个是vectors.c提供的vectors数组。

借助mmu.h中的SETGATE宏

![image-20221012173857503](C:\Users\xumin\AppData\Roaming\Typora\typora-user-images\image-20221012173857503.png)

它有五个参数。

gate：门描述符

第二个参数istrap：是否为trap descriptor。用于选择门的类型。不涉及特权切换，这里填false  中断门

第三个参数sel：代码段选择子  表示用于中断/陷阱处理程序的代码段选择器

第四个参数off：偏移量

第五个参数dpl：权限等级限制

tools/vector.c`笨拙的生成了`vector.S`，可以直接通过extern使用。（因为它被设置为全局变量`.global`）

__vectors[]  这个数组中存储着ISR表（中断服务程序）中所有项的入口地址，定义为外部变量，供初
始化表使用

lidt()：让CPU知道IDT数组已经初始化完毕，并将IDT表的起始地址加载到IDTR寄存器中（CPU通过IDT寄存
器IDTR的内容来寻址IDT的起始地址）。

![image-20221016164759824](C:\Users\xumin\AppData\Roaming\Typora\typora-user-images\image-20221016164759824.png)



![image-20221012182328375](C:\Users\xumin\AppData\Roaming\Typora\typora-user-images\image-20221012182328375.png)

全局变量 idt数组

for循环对每个中断入口初始化

```C
void
idt_init(void) {
     /* LAB1 YOUR CODE : STEP 2 */
     /* (1) Where are the entry addrs of each Interrupt Service Routine (ISR)?
      *     All ISR's entry addrs are stored in __vectors. where is uintptr_t __vectors[] ?
      *     __vectors[] is in kern/trap/vector.S which is produced by tools/vector.c
      *     (try "make" command in lab1, then you will find vector.S in kern/trap DIR)
      *     You can use  "extern uintptr_t __vectors[];" to define this extern variable which will be used later.
      * (2) Now you should setup the entries of ISR in Interrupt Description Table (IDT).
      *     Can you see idt[256] in this file? Yes, it's IDT! you can use SETGATE macro to setup each item of IDT
      * (3) After setup the contents of IDT, you will let CPU know where is the IDT by using 'lidt' instruction.
      *     You don't know the meaning of this instruction? just google it! and check the libs/x86.h to know more.
      *     Notice: the argument of lidt is idt_pd. try to find it!
      */
      extern uintptr_t __vectors[];//直接调 （1）
      for(int i=0;i<256;i++)
      {
	      SETGATE(idt[i], 0, GD_KTEXT, __vectors[i], DPL_KERNEL);//（2）
      }
      lidt(&idt_pd);//(3)
}
```



**问题3**

![image-20221012183812490](C:\Users\xumin\AppData\Roaming\Typora\typora-user-images\image-20221012183812490.png)

关键要看trap_dispatch函数



当产生一个中断时，找到对应中断号，然后根据其中的段选择子作为GDT的index找到GDT的一项，获得
基地址，然后将基地址与我们先前得到的偏移地址相加，即得到了我们的中断处理程序的地址。如下图
所示。



```C
switch (tf->tf_trapno) {
    case IRQ_OFFSET + IRQ_TIMER:
        /* LAB1 YOUR CODE : STEP 3 */
        /* handle the timer interrupt */
        /* (1) After a timer interrupt, you should record this event using a global variable (increase it), such as ticks in kern/driver/clock.c
         * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().
         * (3) Too Simple? Yes, I think so!
         */
	ticks++;
	if(ticks % TICK_NUM==0)
	{
		print_ticks();
	}
	break;
```

![image-20221012184616454](C:\Users\xumin\AppData\Roaming\Typora\typora-user-images\image-20221012184616454.png)





## 中断处理实现

系统将所有的中断事件统一进行了编号（0～255），这个编号称为中断向量。

__中断初始化__

操作系统内核启动以后，会通过 idt_init 函数初始化 idt 表 (参见trap.c)，而其中 vectors 中存储了中断处理程序的入口地址。

__中断的处理过程__

trap函数（定义在trap.c中）是对中断进行处理的过程，所有的中断在经过中断入口函数__alltraps预处理后 (定义在 trapasm.S中) ，都会跳转到这里。在处理过程中，根据不同的中断类型，进行相应的处理。

